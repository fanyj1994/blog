### 6-1 Vue
Vue 是一种组件化的组织方式，其组件可以分为全局组件以及单页面组件，全局组件通过 `Vue.component(name, option)` 来创建。更常见的是单页面组件，一个单页面组件一般由 `template`, `script` 以及 `style` 三部分组成。基本对应一个 HTML 页面的结构样式行为三部分，当然不止那么简单，可以说，任何一个组件由于其内部的双向数据绑定以及状态的变化处理，使其可维护性以及可扩展性变得十分灵活，合理的组件分割可以是一个应用各个部分低耦合，实现分治的效果。

Vue 单文件组件一般通过三步走来应用在页面之中，首先是通过 `import` 关键字引入组件，然后是在要镶嵌父组件的 `components` 关键字中注册组件，最后，通过注册的组件名在页面的相关位置实例化组件，例如一个名字为 `child` 的组件可以通过 `<child></child>` 来实例化，这样一个编辑好的单文件组件就成功地添加到了需要的位置。

Vue 组件的 data 属性之所以只可以为函数的原因是，每一个组件都可能被多次实例化，如果为一个对象，则所有基于该组件的实例将会共享同样的数据对象，而其为一个函数的时候，将在每次实例化的时候，调用函数创建相应的副本。同样，data 中的所有数据都可以通过 `vm.$data` 来访问。

常用的一些 HTTP 请求方法： post/delete/put/get(增删改查)

### 6-2 Vue
Vue 通过 VueRouter 来实现路由功能，使用 VueRouter 的时候，需要先导入 VueRouter，并通过 `Vue.use(VueRouter)` 全局操作来使用路由对象。基本使用步骤如下：

1. 定义路由组件，组件可以通过 `import` 导入

``` Vue
import Foo from 'components/foo'
import Bar from 'components/bar'
```

2. 定义路由，设置路由与组件的映射关系

``` Vue
const routes = [
  { path: '/foo', component: Foo },
  { path: '/bar', component: Bar }
]
```
3. 使用 `new VueRouter` 创建路由实例

``` Vue
const router = new VueRouter({
  routes  // 是routes: routes 的简写
})
```

4. 在根节点挂载路由，使全局可使用路由功能

``` Vue
new Vue({
  router
}).$mount('#app')
```

事实上，通常可以将 2 和 3 两步合写，如果挂载点在另一个组件，可以直接通过 `export` 来导出：

``` Vue
export default new VueRouter({
  routes: [
    { path: '/foo', component: Foo },
    { path: '/bar', component: Bar }
  ]
})
```

动态路由的路径信息以冒号 : 来标识，动态路由参数会存储在 `$route.params`中，例如 `user\:id` 中 id 这样的动态属性可以通过 `$route.params.id` 来访问。如果路由中有多段路径，它们将会以对象的形式存入 `$route.params` 中。

从上面可以看出，路由映射关系由 `path` 以及 `component` 两者来一一对应，但是，这并不是说，一个组件只可以匹配一个路由信息，组件可以匹配不同路由，实现复用。

``` Vue
new VueRouter({
  routes: [
    { path: '/foo', component: Foo },
    { path: '/foo/index', component: Foo }
  ]
})
```

如同组件通过嵌套实现复用一样，Vue 中的路由也同样可以通过嵌套来实现多层路由的渲染，也就是说，一个组件渲染进入一个路由入口 `<router-view></router-view>` 的时候，组件内部同样可以包含路由入口。要实现子路由，只需要在路由映射表中设置 `children` 选项，来实现子路由的嵌入。

``` Vue
<template>
  <div id="app">
    <router-view></router-view> <!-- 第一层路由入口 -->
  </div>
</template>
<script>
const parent = {
  template: `
    <div>
      <p>这是父组件{{ $route.params.name }} </p>
      <router-view></router-view>   // 父组件内部的第二层路由入口
    </div>
    `
}

// 定义子组件
const child = {
  template: '<p>这是子组件</p>'
}

// 实例化路由以及路由映射关系
const router = new VueRouter({
  routes: [
    {
      path: '/parent/:name',
      component: parent,
      children: [
        {
          path: 'child',
          component: child
        }
      ]
    }
  ]
})

// 挂载 Vue
new Vue({
  router
}).$mount('#app')
</script>
```

在上面的例子中，使用到了 `<router-link>` 标签来建立路由导航，其功能在于生成一个超链接标签。同时使用 `<router-view>` 来设置路由嵌入位置。

除了使用 `<router-link>` 来直接嵌入导航，还可以通过函数式编写代码来实现同样的效果，router 提供 `router.push(location)`、`router.replace(location)` 以及 `router.go(n)` 三种方法实现这样的功能。这些方法可以直接接受一个路由信息的对象，例如：

`router.push({path: '/path', params: {id: 1, name: 'fan'}, query: {hobby: 'basketball'}})`

在进行路由跳转的时候，长串的路由路径显得很冗杂，故而在配置路由信息的时候，每个路由还可以接受一个 `name` 属性，在路由跳转的时候，可以直接通过 name 属性来更方便显式地调用。这个属性可以用在函数式以及 `<router-link></router-link>` 中。

命名路由，可以通过给router-view传递name属性，在路由映射表的components参数下以name: component的形式将特定的组件匹配到特定的路由，在这种的设定中，有一个default选项，用于没有name属性时其的渲染位置。

### axios
axios 是一个基于 Promise 的 发送 HTTP 请求的客户端，其可以在浏览器以及 Node.js 中运行。

通过 axios 发送一个简单的 GET 请求是这样的：

``` JavaScript
// 不带参数
axios.get('/user?id=12345')
  .then(function (re) {
    // 数据回调处理
  })
  .catch(function (er) {
    //错误处理
  })

// 同样的处理，用带参数形式
axios.get('/user', {
  params: {
    id: 12345
  }
})
.then(function (re) {
  数据处理
})
.catch(function (er) {
  错误处理
})
```

发送 POST 请求如下：
``` JavaScript
axios.post('/user', {
  name: 'fan',
  age: 24
})
.then(re => {数据处理})
.catch(er => {错误处理})
```

除了显式发送请求，还可以通过配置 `axios()` 方法来获取请求。详见文档。

### 6-3 HTML
在 `<table>` 中，可以通过 `<col>` 标签来定制表格列的一些属性，一组 `<col>` 通常使用一对 `<colgroup>` 标签来包裹起来，例如宽度(width)、对齐方式(align)等。另外该标签在 HTML 标准中不用闭合。

``` HTML
<table>
  <colgroup>
    <col align="center" width="200px">
    <col align="right" width="400px">
  </colgroup>
  <tr>
    <td>一</td>
    <td>二</td>
  </tr>
</table>
```
在上面这段代码中，通过 `<col>` 为表格的两个列分别设置了不同的宽度和文本对齐方式，这样的设置，一方面不需要在表格的行列标签上直接设置冗杂的属性，当表格元素需要重用的时候，在其他地方则不会受到多余属性的影响。

### 6-5 Vue
当路由映射关系中有多个同级的出口，为了为不同的组件匹配不同的出口，则会用到命名视图，也就是说，我们可以拥有多个并列的单独的命名视图，而为了达到具体的准确匹配，则需要为 `<router-view></router-view>` 分别设置 **name** 属性，并在路由映射关系中分别一一给相关的 **name** 属性匹配相应的组件，当路由出口没有 **name** 属性的时候，其名字为 **default**.要注意的是，由于同一级有多个视图，在配置路由关系的时候为了避免出错，需要将 **
component** 改为 **components**.

``` Vue
// 示例代码
<div>
  <router-view name="a"></router-view>   <!-- 渲染componentA -->
  <router-view name="b"></router-view>   <!-- 渲染componentB -->
  <router-view></router-view>   <!-- 渲染componentC -->
</div>

// 路由配置
new VueRouter({
  routes: [
    {
      path: '/',
      components: {
        a: componentA,
        b: componentB,
        default: componentC
      }
    }
  ]
})
```

路由的**别名**和**重定向**机制可以实现突破路由映射关系的限制，实现更灵活的路由匹配。

**重定向**通过 `redirect` 参数来配置，当跳转到定义好的路由路径之时，会跳转到它的重定向路径对应的组件。例如：

``` Vue
new VueRouter({
  routes: [
    {path: '/a', redirect: '/b'}
  ]
})
```

在这个例子中，当打开 **/a** 的时候，会直接跳转到 **/b**. 重定向的目标还可以设置为一个命名组件。

``` Vue
new VueRouter({
  routes: [
    {path: '/a', redirect: {name: componentB}}
  ]
})
```

在上面的例子中，**/a** 的对应组件被重定向到了渲染 componentB.

**别名**通过 **alias** 属性指定。指的是可以为路由路径设置其他名字，而其匹配规则并不会改变，也就是说，如果设置 **/a** 的别名为 **/b**，其跳转的路由 URL 会显示为 **/b**，但其匹配规则仍然会表现为 '/a' 的匹配关系。

#### REST
REST 全称叫做 REprestation State Transfer, 是一种定义 Client 和 Server 之间的数据交换形式，其真正是不具备实用性的，实用的是基于其设计的 RESTful 风格的网络服务接口。再通俗点讲，就是资源以某种表现形式（JSON 等）进行状态（GET/POST等）转移。

#### Vue 组件间传递数据
在实际的开发环境中，经常需要组件之间传递数据，对于 Vue 来说，其传递数据的行为遵循从上往下使用 props 进行，从下往上通过自定义事件进行。

``` HTML
<div id="app">
  <p>{{total}}</p>
  <!-- 监测到 crement 函数执行时，对应地执行 incrementTotal -->
  <button-counter v-on:increment="incrementTotal"></button-counter>
  <button-counter v-on:increment="incrementTotal"></button-counter>
</div>
```

``` Vue
Vue.component('button-counter', {
  template: '<button v-on:click="increment">{{counter}}</button>',
  data () {
    return {
      counter: 0
    }
  },
  methods: {
    increment () {
      this.counter++
      this.$emit('increment')   // 如果要监测这个方法，就要用 $emit() 方法触发事件
    }
  }
})

new Vue({
  data () {
    return {
      total: 0
    }
  },
  methods: {
    incrementTotal () {
      this.total += 1
    }
  }
}).$mount('#app')
```

### 6-7 HTML5
HTML5 新增了文件上传表单元素 `input:file`，其与 FileReader 结合可以实现文件的实时预览。`<input type="file">` 接受一个 **accept** 属性，来表明可接受的文件类型，例如 `accept="image/*"` 表示接受所有的图像类型元素。上传文件之后，这个元素会返回一个 `files` 属性，来表示接收到的文件列表，可以用 `length` 属性来访问其数量。

用 FileReader 对象可以读取，一般使用 new 操作符来新建一个 FIleReader 实例，使用其实例的 `readAsDataURL()` 方法可以读取文件，该方法接受一个文件对象为参数。然后可以在 FileReader 对象的 onload 方法中使用 event.target.result 来获取读取的文件。

### 6-12 Vuex
Vuex 状态管理是集中式管理 Vue 各组件间的数据状态，所谓集中，体现在一种 store 模式，将 store 中的所有 state 变更全部通过自身的 action 来驱动。

> 组件不允许直接修改属于 store 实例的 state，而应执行 action 来分发 (dispatch) 事件通知 store 去改变，我们最终达成了 Flux 架构。这样约定的好处是，我们能够记录所有 store 中发生的 state 改变，同时实现能做到记录变更 (mutations) 、保存状态快照、历史回滚/时光旅行的先进的调试工具。
> 
Vuex 采用单一状态树，用一个对象就可以映射到整个应用。而子模块中使用需要的状态，则会通过状态变更事件分发到其中。

不能直接改变 state ，只能通过显式提交(commit) mutations 之后，才能改变 state

下面是一个简单的 Vuex 状态变更实例：

``` JavaScript
// 在模块的开发模式中，必须先用 Vue.use() 实例化
const store = new Vuex.Store({
  state: {
    count: 0
  },
  // mutations 是改变 state 的唯一途径
  mutations: {
    increment (state) {
      state.count++
    }
  }
})

// 通过 commit 操作来触发一次状态变更
store.commit('increment')

// 之后可以显式获取 state
console.log(store.state.count)
```

如何与 DOM 元素响应结合呢？肯定是用通过事件触发，在事件触发中使用 store.commit() 方法，这样就可以操作 state 变更，当然，变更之后的 state 数据还是 state 状态树之中，如果想要再返回视图层，最方便的法子是通过 computed 计算属性来实时获取数据变更： 

```
computed: {
  count () {
    return store.state.count
  }
}
```

所以，一次最简单的通过 Vuex 来管理状态的过程大概是这样的。

1. 新建 `Vuex.Store()` 实例
2. 在 state 中声明状态，在 mutations 中注册状态变更函数
3. 在组件事件中通过 `store.commit()` 提交变更请求（激发 mutation）
4. 在 computed 属性中实时监测 store.state 的变更，以更新 View 层

可以看[官方基本示例](https://jsfiddle.net/n9jmu5v7/1269/)来增强理解

上面只是一个简单的示例，在模块化的开发模式中，总不能在每个需要 state 检测的组件中导入吧？当然不能，Vuex 提出的解决方案是：在根组件中注入 store 选项。这样，所有的子组件都可以通过 `this.$store` 来访问 store 中的状态。
``` vue
const app = new Vue({
  el: '#app',
  store,  // 把store对象提供给store选项，就可以实现全局注入store实例所有子组件
})
```

### 6-13 Vuex
当项目中包含多个 state 的时候，Vuex 为我们提供一个 mapState 函数来帮助我们生成计算属性，而不是一个个地生成。这个函数需要从 Vuex 中引入。可以通过扩展运算符将 mapState 函数与本地计算属性混合。

在很多时候，我们需要在既有 state 属性的基础上，派生出一些特殊的属性，例如筛选出一些状态，这个时候，就是 Getters 选项出场的时候了，这个方法的使用和 mutations 类似，只不过后者用于状态变更，Getters 用于状态选择。在使用 Getters 的时候，可以传入第一个参数 state，以及第二个参数 Getters 本身相对应的，我们同样可以用过计算属性来获取 Getters 结果，通过 store.getters 来获取相应的 Getters 状态。

在 Getterss 很多的情况下，Vuex 同样提供一个 mapGetters 辅助计算函数来降低代码量。

为了进一步简化 mapState 和 mapGetters 函数，这两个函数可以直接通过简写形式来得到相应的状态，例如：

``` vue
mapGetters({
  'count',
  /* 上面的写法将store.getters.count 赋值给 *this.count，因为同名，所以直接写一个就可以，
  * 如果全部保持组件数据与状态数据同名，可以直
  * 接给map函数传入数组
  times: 'count'
  /*
    上面这种写法是为Getters属性另起一个名字，
    这个时候可以简单滴以对象的形式来赋值，相当于
    this.times = store.getters.count
   */
})
```
