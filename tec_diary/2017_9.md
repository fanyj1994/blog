### 9-13
codewar 上的一个[算法题](https://www.codewars.com/kata/where-my-anagrams-at/train/javascript)，基本要做的事情是判断两个字符串是否包含完全相同的字符，字符的位置可以不一样。我的思路较为繁琐，通过遍历的方法一个一个字符地进行比较。但是这个题更好的思路是利用数组的 `sort()` 方法将两个字符串进行排序，然后比较即可以。如下：

``` JS
function anagrams(word, words) {
  return words.filter(item => {
    return item.split('').sort().join('') === word.split('').sort().join('')
  })
}
```

### 9-19
今天重新巩固正则表达式的基本特性，现在回忆如下：
1. 元字符。`.` 表示匹配任意一个字符，`*` 表示匹配 0 个或多个字符，`+` 匹配 1 个或多个字符，`[]` 匹配方括号内的任意字符集，`[^]` 否定匹配，匹配不是方括号内的字符集，`?` 匹配 0 次或 1 次，`{n, m}` 匹配 n 到 m 次，`()` 匹配括号内的一组字符， `|` 或运算符，`^` 匹配开头， `$` 匹配结尾。
2. 简写字符集。`\w` 匹配所有数字字母字符，相当于 `[a-zA-Z0-9_]`， `\d` 匹配所有数字字符， `\s` 匹配所有空白字符，以上的大写形式表示相反的意义。还有一些类似于换行符之类的，用到时查阅。
3. 前后关联约束。并不会匹配到自身意义，而是用来进行一些约束，表示前面或者后面出现的某些字符，`?=` 表示前面出现某些字符， `?!` 前置否定，表示前面不能出现，`?<=` 表示后置存在，某些字符的后面出现， `?<!` 后置否定，后面不存在。例如：`(?=\s)[a-z]` 表示前面是空白字符的小写字母。

### 9-26
Node 中采用 CommonJS 的模块加载规范，每一个 `.js` 结尾的文件都是一个单独的模块，除了使用 `module.exports` 暴露出来的变量，其它变量都是对外不可见的。其并非是采用了专门的语法，而是根据 JS 的函数式特征，在解析一个模块的时候，用立即执行匿名函数将模块内的所有语句进行包裹。使用 `module.exports = variable` 暴露出来的变量，可以通过 `const my_variable = require('variable')`  来引入，然后使用 my_variable 进行访问使用。